{"status": "broken", "description": "\n    Verify the player behaves correctly when receiving a getConfig message (06) over the websocket.\n\n    :param module_dut:\n    :param mock_player_services_control:\n    ", "parameters": [{"name": "config_properties", "value": "None"}], "labels": [{"name": "tag", "value": "nightly"}, {"name": "tag", "value": "priority3"}, {"name": "tag", "value": "cloud_connection_stats"}, {"name": "parentSuite", "value": "cloud.lechmere"}, {"name": "suite", "value": "test_mock_lechmere_connections"}, {"name": "host", "value": "b34e35e641fa"}, {"name": "thread", "value": "1-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython2"}, {"name": "package", "value": "cloud.lechmere.test_mock_lechmere_connections"}], "stop": 1683576795411, "uuid": "4763a30c-8133-4158-badf-e5dbf38c598d", "historyId": "cf3d3a0342c00a161515252118b08a78", "name": "test_get_config[Default Mock Config]", "start": 1683576604360, "fullName": "cloud.lechmere.test_mock_lechmere_connections#test_get_config[Default Mock Config]", "statusDetails": {"message": "TimeoutError: Timeout: waited 191.0 seconds (180 iterations)", "trace": "module_dut = SonosZoneComponent(id=139946393042704, ip=172.19.255.253, modelNumber=S36, serialNumber=000386103616, architecture=fury, hardware_version=1.36.1.0-1.0)\nmock_player_services_control = <webserver.helpers.mock_player_cloud_services_control.MockPlayerCloudServicesControl object at 0x7f47c265bbd0>\n\n    @pytest.mark.parametrize('config_properties', [None], ids=['Default Mock Config'])\n    @pytest.mark.usefixtures('module_dut', 'mock_player_services_control')\n    def test_get_config(module_dut, mock_player_services_control):\n        \"\"\"\n        Verify the player behaves correctly when receiving a getConfig message (06) over the websocket.\n    \n        :param module_dut:\n        :param mock_player_services_control:\n        \"\"\"\n        zp = module_dut\n        wait_until_true(lambda: len(mock_player_services_control.get_zp_registered(zp)) > 0, timeout_seconds=10, iteration_delay=1,\n                        reason=\"Looking for <{}>'s registration message\".format(zp.friendly_name))\n    \n        # Tell mock to send check alive to ZP\n        mock_player_services_control.check_alive(zp)\n    \n        # Get the check alive response from the mock\n>       wait_until_true(lambda: mock_player_services_control.get_last_check_alive(zp), timeout_seconds=10)\n\ncloud/lechmere/test_mock_lechmere_connections.py:51: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npredicate = <function <lambda> at 0x7f47b867a578>, iteration_delay = 1.05\ntimeout_seconds = 190.0, retry = None, info_threshold = 1.0, reason = ''\nstart_delay = 0.0, final_predicate = None\n\n    def wait_until_true(predicate, iteration_delay=0.05, timeout_seconds=45,\n                        retry=None, info_threshold=1.0, reason='', start_delay=0.0,\n                        final_predicate=None):\n        \"\"\"\n        Wait until predicate returns True.\n    \n        :param predicate: method which evaluates the wait condition and returns\n            a boolean\n        :type predicate: callable returning a bool\n        :param float iteration_delay: number of seconds to sleep between each call\n            to the predicate\n        :param int timeout_seconds: number of seconds to wait for predicate to\n            return True.\n        :param retry: optional function to be called on each iteration\n        :type retry: lambda or None\n        :param float start_delay: Hard sleep before evaluating predicate. It will\n            still use timeout_seconds thereafter to evaluate predicate.\n        :param final_predicate: When passed the 'final_predicate' is used to make a final\n            attempt of the condition being waited on.  The 'final_predicate' is useful to\n            allow a predicate to log failure context for the wait loop in the event that\n            the final attempt to validate the condition fails.\n        :type final_predicate: callable returning a bool\n        :return: The elapsed time until the condition was met in seconds\n        :rtype: float\n    \n        \"\"\"\n        if start_delay > 0.0:\n            logger.info(\"Won't evaluate for {} seconds\".format(start_delay))\n            time.sleep(start_delay)\n        # avoid an int-to-float conversions every time through the loop\n        timeout_seconds = float(timeout_seconds)\n        iteration_delay = float(iteration_delay)\n    \n        timeout_increment, iteration_increment = get_wait_until_true_increments()\n        if any([iteration_increment, timeout_increment]):\n            logger.debug(\"Incrementing wait_until_true values: \"\n                         \"timeout_seconds=%s, iteration_delay=%s\",\n                         timeout_increment, iteration_increment)\n            timeout_seconds += float(timeout_increment)\n            iteration_delay += float(iteration_increment)\n    \n        iterations = 0\n        elapsed = 0.0\n        t0 = time.time()\n        while elapsed <= timeout_seconds:\n            iterations += 1\n            if predicate():\n                elapsed = time.time() - t0\n                if elapsed >= info_threshold:\n                    logger.info(\"wait_until_true: Waited %s seconds\" % elapsed)\n                return elapsed\n    \n            # calculate elapsed time in case retry() takes non-trivial time\n            guaranteed_sleep(iteration_delay)\n            if retry:\n                retry()\n            elapsed = time.time() - t0\n    \n        # If we were passed a final_predicate, make a last attempt so the caller\n        # can have a chance to log the failure context in the event of a final failure\n        if final_predicate is not None:\n            if final_predicate():\n                # only log the wait time if it is 'significant' (defined somewhat\n                # arbitrarily as >= 1 sec)\n                elapsed = time.time() - t0\n                logger.info(\"wait_until_true: Waited %s seconds\" % elapsed)\n                return elapsed\n    \n        raise TimeoutError('{}waited {:.4} seconds ({} iterations)'.format(\n>           reason + ', ' if reason else '', elapsed, iterations))\nE       TimeoutError: Timeout: waited 191.0 seconds (180 iterations)\n\n../../../.venv/local/lib/python2.7/site-packages/sonos/services/common.py:407: TimeoutError"}, "attachments": [{"source": "4a72fbba-1f4f-4992-b7b5-a86ff5e09b22-attachment.txt", "type": "text/plain", "name": "stdout"}, {"source": "40dca6e0-fe91-47e5-a538-bb59285175cc-attachment.txt", "type": "text/plain", "name": "stderr"}]}